"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const color = require("@vibrant/color");
const vbox = require("./vbox.cjs");
const pqueue = require("./pqueue.cjs");
const fractByPopulations = 0.75;
function _splitBoxes(pq, target) {
  let lastSize = pq.size();
  while (pq.size() < target) {
    const vbox2 = pq.pop();
    if (vbox2 && vbox2.count() > 0) {
      const [vbox1, vbox22] = vbox2.split();
      if (!vbox1) break;
      pq.push(vbox1);
      if (vbox22 && vbox22.count() > 0) pq.push(vbox22);
      if (pq.size() === lastSize) {
        break;
      } else {
        lastSize = pq.size();
      }
    } else {
      break;
    }
  }
}
const MMCQ = (pixels, opts) => {
  if (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {
    throw new Error("Wrong MMCQ parameters");
  }
  const vbox$1 = vbox.VBox.build(pixels);
  vbox$1.histogram.colorCount;
  const pq = new pqueue.PQueue((a, b) => a.count() - b.count());
  pq.push(vbox$1);
  _splitBoxes(pq, fractByPopulations * opts.colorCount);
  const pq2 = new pqueue.PQueue(
    (a, b) => a.count() * a.volume() - b.count() * b.volume()
  );
  pq2.contents = pq.contents;
  _splitBoxes(pq2, opts.colorCount - pq2.size());
  return generateSwatches(pq2);
};
function generateSwatches(pq) {
  const swatches = [];
  while (pq.size()) {
    const v = pq.pop();
    const color$1 = v.avg();
    swatches.push(new color.Swatch(color$1, v.count()));
  }
  return swatches;
}
exports.MMCQ = MMCQ;
//# sourceMappingURL=index.cjs.map
