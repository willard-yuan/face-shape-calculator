{"version":3,"file":"index.js","sources":["../../../src/pipeline/index.ts"],"sourcesContent":["import { applyFilters } from \"@vibrant/image\";\nimport type { ImageData } from \"@vibrant/image\";\nimport type { Quantizer } from \"@vibrant/quantizer\";\nimport type { Generator } from \"@vibrant/generator\";\nimport type { Filter, Palette, Swatch } from \"@vibrant/color\";\n\n/**\n * @private\n */\nexport class Stage<T> {\n\tprivate _map: { [name: string]: T } = {};\n\tconstructor(protected pipeline: BasicPipeline) {}\n\tnames() {\n\t\treturn Object.keys(this._map);\n\t}\n\thas(name: string) {\n\t\treturn !!this._map[name];\n\t}\n\tget(name: string) {\n\t\treturn this._map[name];\n\t}\n\tregister(name: string, stageFn: T) {\n\t\tthis._map[name] = stageFn;\n\t\treturn this.pipeline;\n\t}\n}\n\n/**\n * @private\n */\nexport interface ProcessResult {\n\tcolors: Swatch[];\n\tpalettes: { [name: string]: Palette };\n}\n\n/**\n * @private\n */\nexport interface StageOptions {\n\tname: string;\n\toptions?: any;\n}\n\n/**\n * @private\n */\nexport interface ProcessOptions {\n\tfilters: string[];\n\tquantizer: string | StageOptions;\n\tgenerators: (string | StageOptions)[];\n}\n\n/**\n * @private\n */\ninterface StageTask<Q> {\n\tname: string;\n\tfn: Q;\n\toptions?: any;\n}\n\n/**\n * @private\n */\ninterface ProcessTasks {\n\tfilters: StageTask<Filter>[];\n\tquantizer: StageTask<Quantizer>;\n\tgenerators: StageTask<Generator>[];\n}\n\n/**\n * @private\n */\nexport interface Pipeline {\n\t// quantizer: Stage<Quantizer>\n\t// generator: Stage<Generator>\n\tprocess(imageData: ImageData, opts: ProcessOptions): Promise<ProcessResult>;\n}\n\n/**\n * @private\n */\nexport class BasicPipeline implements Pipeline {\n\tprivate _buildProcessTasks({\n\t\tfilters,\n\t\tquantizer,\n\t\tgenerators,\n\t}: ProcessOptions): ProcessTasks {\n\t\t// Support wildcard for generators\n\t\tif (generators.length === 1 && generators[0] === \"*\") {\n\t\t\tgenerators = this.generator.names();\n\t\t}\n\t\treturn {\n\t\t\tfilters: filters.map((f) => createTask(this.filter, f)),\n\t\t\tquantizer: createTask(this.quantizer, quantizer),\n\t\t\tgenerators: generators.map((g) => createTask(this.generator, g)),\n\t\t};\n\t\tfunction createTask<Q>(\n\t\t\tstage: Stage<Q>,\n\t\t\to: string | StageOptions,\n\t\t): StageTask<Q> {\n\t\t\tlet name: string;\n\t\t\tlet options: any;\n\t\t\tif (typeof o === \"string\") {\n\t\t\t\tname = o;\n\t\t\t} else {\n\t\t\t\tname = o.name;\n\t\t\t\toptions = o.options;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tfn: stage.get(name)!,\n\t\t\t\toptions,\n\t\t\t};\n\t\t}\n\t}\n\tfilter: Stage<Filter> = new Stage(this);\n\tquantizer: Stage<Quantizer> = new Stage(this);\n\tgenerator: Stage<Generator> = new Stage(this);\n\tasync process(\n\t\timageData: ImageData,\n\t\topts: ProcessOptions,\n\t): Promise<ProcessResult> {\n\t\tconst { filters, quantizer, generators } = this._buildProcessTasks(opts);\n\t\tconst imageFilterData = await this._filterColors(filters, imageData);\n\t\tconst colors = await this._generateColors(quantizer, imageFilterData);\n\t\tconst palettes = await this._generatePalettes(generators, colors);\n\t\treturn {\n\t\t\tcolors,\n\t\t\tpalettes,\n\t\t};\n\t}\n\tprivate _filterColors(filters: StageTask<Filter>[], imageData: ImageData) {\n\t\treturn Promise.resolve(\n\t\t\tapplyFilters(\n\t\t\t\timageData,\n\t\t\t\tfilters.map(({ fn }) => fn),\n\t\t\t),\n\t\t);\n\t}\n\tprivate _generateColors(\n\t\tquantizer: StageTask<Quantizer>,\n\t\timageData: ImageData,\n\t) {\n\t\treturn Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n\t}\n\tprivate async _generatePalettes(\n\t\tgenerators: StageTask<Generator>[],\n\t\tcolors: Swatch[],\n\t) {\n\t\t// Make a promise map that will run them \"concurrently\" (but return in expected result)\n\t\tconst promiseArr = await Promise.all(\n\t\t\tgenerators.map(({ fn, options }) => Promise.resolve(fn(colors, options))),\n\t\t);\n\t\t// Map the values to the expected name\n\t\treturn Promise.resolve(\n\t\t\tpromiseArr.reduce(\n\t\t\t\t(promises, promiseVal, i) => {\n\t\t\t\t\tpromises[generators[i]!.name] = promiseVal;\n\t\t\t\t\treturn promises;\n\t\t\t\t},\n\t\t\t\t{} as { [name: string]: Palette },\n\t\t\t),\n\t\t);\n\t}\n}\n"],"names":[],"mappings":";AASO,MAAM,MAAS;AAAA,EAErB,YAAsB,UAAyB;AAAzB,SAAA,WAAA;AADtB,SAAQ,OAA8B,CAAC;AAAA,EAAA;AAAA,EAEvC,QAAQ;AACA,WAAA,OAAO,KAAK,KAAK,IAAI;AAAA,EAAA;AAAA,EAE7B,IAAI,MAAc;AACjB,WAAO,CAAC,CAAC,KAAK,KAAK,IAAI;AAAA,EAAA;AAAA,EAExB,IAAI,MAAc;AACV,WAAA,KAAK,KAAK,IAAI;AAAA,EAAA;AAAA,EAEtB,SAAS,MAAc,SAAY;AAC7B,SAAA,KAAK,IAAI,IAAI;AAClB,WAAO,KAAK;AAAA,EAAA;AAEd;AAyDO,MAAM,cAAkC;AAAA,EAAxC,cAAA;AAmCkB,SAAA,SAAA,IAAI,MAAM,IAAI;AACR,SAAA,YAAA,IAAI,MAAM,IAAI;AACd,SAAA,YAAA,IAAI,MAAM,IAAI;AAAA,EAAA;AAAA,EApCpC,mBAAmB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA;AAAA,EAAA,GACgC;AAEhC,QAAI,WAAW,WAAW,KAAK,WAAW,CAAC,MAAM,KAAK;AACxC,mBAAA,KAAK,UAAU,MAAM;AAAA,IAAA;AAE5B,WAAA;AAAA,MACN,SAAS,QAAQ,IAAI,CAAC,MAAM,WAAW,KAAK,QAAQ,CAAC,CAAC;AAAA,MACtD,WAAW,WAAW,KAAK,WAAW,SAAS;AAAA,MAC/C,YAAY,WAAW,IAAI,CAAC,MAAM,WAAW,KAAK,WAAW,CAAC,CAAC;AAAA,IAChE;AACS,aAAA,WACR,OACA,GACe;AACX,UAAA;AACA,UAAA;AACA,UAAA,OAAO,MAAM,UAAU;AACnB,eAAA;AAAA,MAAA,OACD;AACN,eAAO,EAAE;AACT,kBAAU,EAAE;AAAA,MAAA;AAGN,aAAA;AAAA,QACN;AAAA,QACA,IAAI,MAAM,IAAI,IAAI;AAAA,QAClB;AAAA,MACD;AAAA,IAAA;AAAA,EACD;AAAA,EAKD,MAAM,QACL,WACA,MACyB;AACzB,UAAM,EAAE,SAAS,WAAW,WAAe,IAAA,KAAK,mBAAmB,IAAI;AACvE,UAAM,kBAAkB,MAAM,KAAK,cAAc,SAAS,SAAS;AACnE,UAAM,SAAS,MAAM,KAAK,gBAAgB,WAAW,eAAe;AACpE,UAAM,WAAW,MAAM,KAAK,kBAAkB,YAAY,MAAM;AACzD,WAAA;AAAA,MACN;AAAA,MACA;AAAA,IACD;AAAA,EAAA;AAAA,EAEO,cAAc,SAA8B,WAAsB;AACzE,WAAO,QAAQ;AAAA,MACd;AAAA,QACC;AAAA,QACA,QAAQ,IAAI,CAAC,EAAE,SAAS,EAAE;AAAA,MAAA;AAAA,IAE5B;AAAA,EAAA;AAAA,EAEO,gBACP,WACA,WACC;AACM,WAAA,QAAQ,QAAQ,UAAU,GAAG,UAAU,MAAM,UAAU,OAAO,CAAC;AAAA,EAAA;AAAA,EAEvE,MAAc,kBACb,YACA,QACC;AAEK,UAAA,aAAa,MAAM,QAAQ;AAAA,MAChC,WAAW,IAAI,CAAC,EAAE,IAAI,QAAA,MAAc,QAAQ,QAAQ,GAAG,QAAQ,OAAO,CAAC,CAAC;AAAA,IACzE;AAEA,WAAO,QAAQ;AAAA,MACd,WAAW;AAAA,QACV,CAAC,UAAU,YAAY,MAAM;AAC5B,mBAAS,WAAW,CAAC,EAAG,IAAI,IAAI;AACzB,iBAAA;AAAA,QACR;AAAA,QACA,CAAA;AAAA,MAAC;AAAA,IAEH;AAAA,EAAA;AAEF;"}